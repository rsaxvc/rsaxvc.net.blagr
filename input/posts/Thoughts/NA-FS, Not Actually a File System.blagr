Title:NA-FS, Not Actually a File System
Author:rsaxvc
CreatedDateTime:2010-02-24T22:18:41
ModifiedDateTime:2010-02-24T22:18:41
Tag:Ext4
Tag:Linux
Tag:Mass storage
Tag:Ubuntu
Tag:ZFS
Tag:filesystem
---
<span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; ">I've worked with several embedded filesystems, from jffs2, to FAT12/16/32, to hard coded tables of filenames and their containing data. What I would like to propose, is not a filesystem, per-se, but an interface.</span><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></div><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; ">I understand that no one filesystem fits every problem. If you need to be able to open a file quickly, FAT won't do it. If you need a tiny driver, don't go with Reiser. If you need flash wear-leveling, your choices are pretty limited to start with. If it only exists in <a class="zem_slink" href="http://en.wikipedia.org/wiki/Random-access_memory" title="Random-access memory" rel="wikipedia">RAM</a>, who wants to bother with a filesystem anyways? My point is that the diversity in these systems is necessary.&nbsp;</div><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></div><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; ">However, interfacing with so many filesystems is a nightmare. Even Linux drops filesystem support quite regularly. How can we improve this? By offloading the burden of filesystem support to the device itself. By necessity, the device already has a driver, and this method adds new capabilities.</div><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></div><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><b>Real World Example One</b>: A media player acting as <a class="zem_slink" href="http://en.wikipedia.org/wiki/USB_mass-storage_device_class" title="USB mass-storage device class" rel="wikipedia">USB mass storage</a>. After loading new MP3s, a media player needs to open each file and scan it for meta data such as the band, length, and volume profile. If the media player were the storage back-end directly, every time another device sends it a file, it parses the file as part of the storage operation, preventing a lengthy power-on.</div><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></div><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><b>Real World Example Two</b>: Utilizing a system like NA-<a class="zem_slink" href="http://en.wikipedia.org/wiki/File_system" title="File system" rel="wikipedia">FS</a>, intelligent memory cards could be swapped with any device supporting NA-FS, without actually changing the backing store. For example, if SD was designed with NA-FS as the interface, then this SD/SDHC/SDXC monkey business would have never been an issue. Small cards could use a compact filesystem like vFAT16, and larger devices could use whatever they needed, from <a class="zem_slink" href="http://en.wikipedia.org/wiki/ExFAT" title="ExFAT" rel="wikipedia">exFAT</a> to <a class="zem_slink" href="http://en.wikipedia.org/wiki/ZFS" title="ZFS" rel="wikipedia">ZFS</a>-based RAID.</div><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></div><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><b>Technical Example</b>: In Linux, there are filesystems like /proc, which are generated at file-access time. NA-FS would support this intrinsically, as actual file i/o is passed down to the device OS.</div><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></div><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><b>Technical Example</b>: Compression - as an intelligent storage device, the bytes on disk don't need to match the bytes at the transaction layer. A smart enough device could compress plain-text documents or use <a class="zem_slink" href="http://en.wikipedia.org/wiki/Portable_Network_Graphics" title="Portable Network Graphics" rel="wikipedia">PNG</a> compression for uncompressed images.</div><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></div><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><b>Downsides</b>:&nbsp;</div><div style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><ul><li>Currently, the media controllers in memory devices are quite limited. Often, they only handle flash wear-leveling, and perhaps block-atomicity.</li><li>No current implementation/standard, just a though I had</li><li>How would features not standard across all filesystems be handled? <a class="zem_slink" href="http://en.wikipedia.org/wiki/Access_control_list" title="Access control list" rel="wikipedia">ACLs</a> come to mind.</li><li>Some features, such as automatic image compressions, would be computationally expensive to implement, for a memory card.</li></ul><div><b>Upsides</b>:</div><div><ul><li>No device would have to enter '<a class="zem_slink" href="http://en.wikipedia.org/wiki/Mass_storage" title="Mass storage" rel="wikipedia">Mass Storage</a> Mode'. Devices could keep functioning normally, and even use NA-FS to transfer information, much like /proc on linux.</li><li>No device would need to support more than two filesystems: NA-FS, and the backing store of choice.</li><li>A filesystem need never worry about a poor fs implementation on a device corrupting it.</li></ul></div></div>
