Title:A New Idea about Realtime Image Processing
Author:rsaxvc
CreatedDateTime:2009-06-12T20:48:54
ModifiedDateTime:2009-06-12T20:48:54
Tag:Electrical Engineering
Tag:OpenCV
Tag:Pixel
Tag:Segmentation (image processing)
Tag:Technology
Tag:YouTube
Tag:imageprocessing
---
<span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; ">The more <a class="zem_slink" href="http://en.wikipedia.org/wiki/Image_processing" title="Image processing" rel="wikipedia">image processing</a> I deal with, the more I'm convinced a better solution is needed than pre-made image <a class="zem_slink" href="http://en.wikipedia.org/wiki/List_of_toolkits" title="List of toolkits" rel="wikipedia">toolkits</a>. Evaluating a 640x480 image, even just once, can be processor intensive. Every processing toolkit I've seen has the same basic parts, an image class/interface, some I/O <a class="zem_slink" href="http://en.wikipedia.org/wiki/Function_%28mathematics%29" title="Function (mathematics)" rel="wikipedia">functions</a>, and some image modification functions. <a class="zem_slink" href="http://opencv.willowgarage.com/wiki/" title="OpenCV" rel="homepage">OpenCV</a> at least gives you raw pointer access to the image, but the problem here is that each of these transforms are always applied sequentially.</span><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></span><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></span><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; ">Some time ago, I wrote a simple <a class="zem_slink" href="http://en.wikipedia.org/wiki/Segmentation_%28image_processing%29" title="Segmentation (image processing)" rel="wikipedia">image-segmentation</a> algorithm. However, because this was a realtime task, it needed to be made as fast as possible(</span><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><a href="http://rsaxvc.net/code/3filter/">see here</a></span><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; ">). What I completed was a giant mess of c/c++, with loops hand-unrolled to remove edge conditions from them. With optimization, 50fps <a class="zem_slink" href="http://en.wikipedia.org/wiki/Best%2C_worst_and_average_case" title="Best, worst and average case" rel="wikipedia">worst-case</a> (P4, 3.2). However, later I needed to add some functionallity to the segmentation algorithm. Re-opening this code was a nightmare. Even though I had plenty of comments, it would've been about 1/6 the size if I hadn't been crunched for <a class="zem_slink" href="http://en.wikipedia.org/wiki/Central_processing_unit" title="Central processing unit" rel="wikipedia">CPU</a> power.</span><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></span><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></span><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; ">So, <a class="zem_slink" href="http://en.wikipedia.org/wiki/Raw_image_format" title="Raw image format" rel="wikipedia">raw image</a> access and image-optimized code are still necessary for real-time image processing (I look forward to doing it in python, whenever that becomes doable).</span><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></span><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></span><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; ">Also, the fewer passes you can make through an image, the better( usually ). The problem with most(perhaps all) premade image toolkits, is that they encourage sequential execution of functions. For example, if I wanted to double contrast, then apply a threshold, and then halve the contrast, the image would be contrasted, then thresholded, then contrasted. We've made a total of three passes through the image to do our three functions. O(N) on the number of functions isn't bad, but it isn't necessary either. It would be faster to say, <a class="zem_slink" href="http://en.wikipedia.org/wiki/Pixel" title="Pixel" rel="wikipedia">Pixel</a>(x,y) = (composition of multiple rules). In this way, the pixels, which now have a single, CPU intensive step, only have to be read and written once. I don't know of a single compiler that can optimize this case.</span><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></span><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; "><br /></span><span class="Apple-style-span" style="color: rgb(0, 0, 0); font-family: 'Times New Roman'; font-size: medium; ">If we can break our image processing down to the pixel level, we can apply multiple complex transformations in one step. If we can do that, we can minimize <a class="zem_slink" href="http://en.wikipedia.org/wiki/Memory_bandwidth" title="Memory bandwidth" rel="wikipedia">memory bandwidth</a> usage and increase our cache utility.</span>
