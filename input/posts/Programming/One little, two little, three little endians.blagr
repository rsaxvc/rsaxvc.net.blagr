Title:One little, two little, three little endians
Author:rsaxvc
CreatedDateTime:2011-03-13T17:47:57
ModifiedDateTime:2011-03-13T17:53:57
Tag:ARM
Tag:MIPS
Tag:PDP-11
Tag:endianness
---
I've done a little work on two different endians. Currently, I've missed out on PDP-endian. Again, the question came up, which one is best, so I'll give it a go at explaining the three and their differences.&nbsp;Endianness, is the pattern of storing a multi-byte word into multiple bytes of memory. In particular, the bytes are often stored most-significant or least significant byte first. You might wonder why anyone would store objects backwards (indeed, little-endian is the only 'language' I know where the 'sentences' are written in ascending order, but the words are written in reverse order). However, there are some distinct advantages to storing words in little-endian order(union alignment and addition/subtraction/multiplication pipelining), as well as there are advantages to storing words in big-endian order( natural treatment of multi-byte objects, easier comparison ).&nbsp;Please keep in mind that with modern processors, some of these reasons end up not meaning nearly as much as they used to.<div><meta http-equiv="content-type" content="text/html; charset=utf-8"><div><br /></div><div><b>Union Alignment</b></div><div>Lets take the following example:</div><div>union{</div><div>uint8_t one;</div><div>uint16_t two;</div><div>uint32_t four;</div><div>}sometype;</div><div><br /></div><div>With little endian, because all the objects are written backwards, the union members one, two, and four can be located at the same address in memory, which can really simplify things at an assembly level. With big endian, two has to be stored 2 bytes past the beginning of the union, and one has to be stored 3 bytes past the beginning of the union. *</div><div><br /></div><div><b>Addition/Multiplication/Subtraction <a class="zem_slink" href="http://en.wikipedia.org/wiki/Pipeline_%28computing%29" title="Pipeline (computing)" rel="wikipedia">Pipelining</a></b></div><div>By storing bytes in little-endian order, something neat happens**. Think back to multi-digit arithmetic(except division). When performing an operation, you always start with the least-significant digit. This is because the less significant digits can only overflow into more significant digits, so when one byte is loaded in, enough information to begin computation is already available.</div><div><br /></div><div><b>Natural Treatment of Object Byte Order</b></div><div>I'm going to call big-endian as natural byte order, because by keeping words in big-endian, things like memcmp() can get a little more efficient. For example, when comparing large objects with memcmp() on a big-endian system, it becomes possible to aggregate compares to full word sizes. This can be significantly more efficient than comparing per byte. (Potentially, you can implement something similar with little-endian, but it incurs an overhead when there is a difference in the two areas of memory, or a per word overhead)***. Also, most network protocols are written in big-endian. This usually isn't much overhead compared to say, generating the data to ship over the network, but for small applications it can build up.&nbsp;</div><div><br /></div><div><b>Comparison and Sign information</b></div><div>By storing the most significant information first in memory, operations requiring sign information or comparison can be implemented more easily(**). Because the sign information is stored earlier in the word, a big-endian compare can complete as soon as there is a difference in the word. This becomes even more important when dealing with objects larger than the native <a class="zem_slink" href="http://en.wikipedia.org/wiki/Word_%28computing%29" title="Word (computing)" rel="wikipedia">word size</a>.</div><div><br /></div><div><b>PDP-endian</b></div><div>I haven't mentioned PDP-endian, because it is such an oddball. Worst of both worlds it seems. As a <a class="zem_slink" href="http://en.wikipedia.org/wiki/16-bit" title="16-bit" rel="wikipedia">16-bit architecture</a>, 16-bit words are stored in little-endian format, but compilers on <a class="zem_slink" href="http://en.wikipedia.org/wiki/PDP-11" title="PDP-11" rel="wikipedia">PDP-11s</a> would store 32-bit words as two consecutive 16-bit little endian words. This makes it extra-confusing. Potentially compilers could be updated to store words in little-endian order, but this architecture is almost entirely dead, and all the other software running on it expects PDP-endian already.</div><div><br /></div><div>*Depending on architecture, the alignment might move things differently, but this scenario is pretty common</div><div>**on systems with memory buses narrower than the cpu word size (this actually happens a lot on embedded stuff (8088, some <a class="zem_slink" href="http://en.wikipedia.org/wiki/ARM_architecture" title="ARM architecture" rel="wikipedia">ARM</a> and some <a class="zem_slink" href="http://en.wikipedia.org/wiki/MIPS_architecture" title="MIPS architecture" rel="wikipedia">MIPS</a> )</div><meta http-equiv="content-type" content="text/html; charset=utf-8"><div>***On systems like ARMv7, you can swap endianness in a single instruction. On little-endian systems, you can still use word compares to speed up memory access, but when the words compared are different, you then have to switch the endianness and figure out the right memcmp return.</div></div>
